\section{Matching species tables with different taxonomic resolution} 

Trait-based approaches are a promising tool in ecology. Unlike taxonomy-based methods, traits may not be constrained to biogeographic boundaries \citep{baird_toward_2011} and have potential to disentangle the effects of multiple stressors \citep{statzner_can_2010}. 

To analyse trait-composition abundance data must be matched with trait databases like \citet{usseglio-polatera_biological_2000}. However these two datatables may contain species information on different taxonomic levels and perhabs data must be aggregated to a joint taxomic level.

taxize can help in this data-cleaning step, providing a reproducible workflow. Here we illustrate this on a small fictitious example.

Suppose we have fuzzy coded trait table with 2 traits with 3 respectively 2 modalities:
<<traitdata>>=
(traits <- read.table(header = TRUE, sep = ';', stringsAsFactors=FALSE, text = 'taxon;T1M1;T1M2;T1M3;T2M1;T2M2
Gammarus sp.;0;0;3;1;3
Potamopyrgus antipodarum;1;0;3;1;3
Coenagrion sp.;3;0;1;3;1
Enallagma cyathigerum;0;3;1;0;3
Erythromma sp.;0;0;3;3;1
Baetis sp.;0;0;0;0;0
'))
@

And want to match this to a table with abundances:
<<abundancedata>>=
(abundances <- read.table(header = TRUE, sep = ';', stringsAsFactors=FALSE, text = 'taxon;abundance;sample
Gammarus roeseli;5;1
Gammarus roeseli;6;2
Gammarus tigrinus;7;1
Gammarus tigrinus;8;2
Coenagrionidae;10;1
Coenagrionidae;6;2
Potamopyrgus antipodarum;10;1
xxxxx;10;2
'))
@


First we do some basic data-cleaning and create a looktable, that will link taxa in trait table with taxa in the abundance table.
<<cleaning>>=
# first we remove ' sp.' from out trait table:
traits$taxon_cleaned <- tolower(gsub(' sp.', '', traits$taxon))

# since abundance tables can be very long with repeating taxa, we look only at unique
# taxon names 
# This will be a lookup-table linking taxon names between both tables
lookup <- data.frame(taxon = tolower(unique(abundances$taxon)), stringsAsFactors=FALSE)
@

The we query the taxonomic hierarchy for both tables, since this is the backbone of this procedure:
<<get_classification, cache=TRUE>>=
require(taxize)
traits_classi <- classification(get_uid(traits$taxon_cleaned))
lookup_classi <- classification(get_uid(lookup$taxon))
@

First we look if we get any direct matches between taxon names:
<<direct_matches>>=
# first search for direct matches
direct <- match(lookup$taxon, traits$taxon_cleaned)
# and add the matched name to our lookup table
lookup$traits <- tolower(traits$taxon[direct])
lookup$type <- ifelse(!is.na(direct), "direct", NA)
lookup
@


<<>>=
# look for cases where taxonomic resolution in abundance data is higher than in trait data:
# here we take the trait-values for the lower resolution
for(i in which(is.na(lookup$traits))){
  if(is.data.frame(lookup_classi[[i]])){
    matches <- tolower(lookup_classi[[i]]$ScientificName) %in% traits$taxon_cleaned
    if(any(matches)){
      lookup$traits[i] <- tolower(lookup_classi[[i]]$ScientificName[matches])
      lookup$type[i] <- lookup_classi[[i]]$Rank[matches]
    }
  }
}
lookup

# look for cases taxonomic resolution in abundance data is lower than in trait data,
# here we need to aggregate the trait-values (eg. median value for modality)

for(i in which(is.na(lookup$traits))){
  # find matches
  agg <- sapply(traits_classi, function(x) any(tolower(x$ScientificName) %in% lookup$taxon[i]))
  if(sum(agg) > 1){
    # add aggregated trait to trait table
    traits <- rbind(traits, c(paste0(lookup$taxon[i], '-aggregated'), apply(traits[agg, 2:6], 2, median), paste0(lookup$taxon[i], '-aggregated')))
    # fill lookup table
    lookup$traits[i] <- paste0(lookup$taxon[i], '-aggregated')
    lookup$type[i] <- 'aggregated'
  }
}
lookup



abundances$traits <- tolower(lookup$traits[match(tolower(abundances$taxon), lookup$taxon)])
abundances

traits[match(abundances$traits, traits$taxon_cleaned), 2:6]
@

